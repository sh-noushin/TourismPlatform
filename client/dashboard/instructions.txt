Angular Admin + SuperUser Dashboard for Tourism Platform
Backend exists (.NET REST API). Build a clean Angular admin UI with zero repeated styles/code.
1) Goal
Create an Angular dashboard that supports Admin and SuperUser users.
1.1 Must-have features (MVP)
•	Login / Logout / Refresh session
•	Dashboard shell layout (professional, well-known dashboard pattern)
o	Left sidebar navigation
o	Topbar with user info + logout
o	Main content outlet
o	Responsive (mobile collapsible sidebar)
•	Houses management
o	List (paged, sortable, filterable)
o	Create/Edit
o	Photos (stage upload -> label + sort -> commit on save)
•	Tours management
o	List (paged, sortable, filterable)
o	Create/Edit
o	Schedules
o	Photos (same staged flow)
•	SuperUser-only
o	Create Admin
o	Manage permission catalog (CRUD permissions)
o	Assign permissions to roles/users
1.2 Backend security rules (UI must follow)
•	Roles: SuperUser, Admin, User
•	Permission claim type: perm
•	Permissions are DB-driven (dynamic), not hard-coded
•	UI must:
o	Hide menu items if user lacks permission
o	Disable buttons/actions if user lacks permission
o	Guard routes with permission/role requirements
•	Auth endpoints exist:
o	register/login/refresh/logout/logout-all (admin uses login/refresh/logout)
•	Use JWT access token + refresh token lifecycle
1.3 “No repetition” rules (mandatory)
•	No repeated CSS across feature pages
•	No repeated colors: define in one SCSS variables file and use everywhere
•	No repeated HTTP error handling: use interceptors
•	No repeated table markup: use one shared Table component
•	No repeated forms layout: shared form-field wrapper styles/components
________________________________________
2) Technology and style decisions
•	Angular (standalone components)
•	SCSS
•	Angular Router with lazy routes
•	Angular Material recommended for dashboard layout (Sidenav/Toolbar/Table/Dialog) but wrapped by your shared UI components to avoid duplication
•	Signals for state (facade/store per feature)
•	Typed API client (OpenAPI generated) OR a thin typed HttpClient layer (but still centralized)
________________________________________
3) Required project structure (DRAW)
Create/organize files like this:
src/app
├─ core
│  ├─ config
│  │  ├─ app-config.ts
│  │  └─ env.tokens.ts                 // API_BASE_URL token
│  ├─ auth
│  │  ├─ auth.facade.ts                // signal state: user, roles, perms, tokens
│  │  ├─ auth.service.ts               // calls backend auth endpoints
│  │  ├─ token.store.ts                // storage strategy for tokens
│  │  ├─ auth.guard.ts
│  │  ├─ role.guard.ts
│  │  ├─ permission.guard.ts
│  │  ├─ permission.util.ts            // helper hasPermission(), isSuperUser()
│  │  └─ jwt.util.ts                   // decode token, extract claims
│  ├─ http
│  │  ├─ auth.interceptor.ts           // attach access token
│  │  ├─ refresh.interceptor.ts        // handle 401 -> refresh -> retry (safe)
│  │  ├─ error.interceptor.ts          // normalize errors + toast
│  │  └─ correlation-id.interceptor.ts // X-Correlation-ID
│  ├─ ui
│  │  ├─ toast.service.ts
│  │  ├─ confirm.service.ts
│  │  └─ loading.service.ts            // optional global loading indicator
│  └─ core.providers.ts
├─ styles
│  ├─ _variables.scss                   // all colors, spacing, radius
│  ├─ _mixins.scss                      // reusable mixins
│  ├─ _typography.scss
│  ├─ _material-theme.scss              // optional: map Material palette to vars
│  └─ index.scss                        // re-export/use entry
├─ shared
│  ├─ ui
│  │  ├─ sf-button/                     // shared button wrapper
│  │  ├─ sf-card/
│  │  ├─ sf-table/                      // reusable table wrapper (paging/sort/actions)
│  │  ├─ sf-form-field/
│  │  ├─ sf-dialog/
│  │  ├─ sf-drawer/
│  │  ├─ sf-page-header/
│  │  ├─ sf-empty-state/
│  │  └─ sf-spinner/
│  ├─ models
│  │  ├─ page.model.ts                  // PageResult<T>, PageRequest
│  │  ├─ table.model.ts                 // column defs, action defs
│  │  └─ filters.model.ts
│  ├─ directives
│  │  └─ has-permission.directive.ts    // *appHasPermission="'houses.manage'"
│  └─ pipes
├─ layout
│  ├─ admin-shell
│  │  ├─ admin-shell.component.ts
│  │  ├─ admin-shell.component.html
│  │  └─ admin-shell.component.scss
│  ├─ sidebar
│  ├─ topbar
│  └─ layout.routes.ts
├─ api
│  ├─ generated/                        // OpenAPI generated client (preferred)
│  └─ api.facade.ts                     // wrapper to expose app-friendly methods
├─ features
│  ├─ auth
│  │  ├─ pages/login/
│  │  └─ auth.routes.ts
│  ├─ houses
│  │  ├─ pages/list/
│  │  ├─ pages/edit/
│  │  ├─ components/house-form/
│  │  ├─ components/house-photos/
│  │  ├─ services/houses.facade.ts
│  │  └─ houses.routes.ts
│  ├─ tours
│  │  ├─ pages/list/
│  │  ├─ pages/edit/
│  │  ├─ components/tour-form/
│  │  ├─ components/tour-schedules/
│  │  ├─ components/tour-photos/
│  │  ├─ services/tours.facade.ts
│  │  └─ tours.routes.ts
│  ├─ users
│  │  ├─ pages/list/
│  │  ├─ pages/create-admin/
│  │  ├─ services/users.facade.ts
│  │  └─ users.routes.ts
│  └─ permissions
│     ├─ pages/permission-list/
│     ├─ pages/permission-assign/
│     ├─ services/permissions.facade.ts
│     └─ permissions.routes.ts
├─ app.routes.ts
└─ app.component.ts
________________________________________
4) SCSS design system (mandatory)
4.1 Variables file
Create: src/app/styles/_variables.scss
Define:
•	Colors:
o	$color-bg, $color-surface, $color-text, $color-muted
o	$color-border
o	$color-primary, $color-primary-contrast
o	$color-danger, $color-warning, $color-success
•	Layout:
o	$radius-sm, $radius-md, $radius-lg
o	$space-1 ... $space-6
o	$shadow-card
•	Sidebar sizes:
o	$sidebar-width, $topbar-height
Rule: No component hardcodes hex colors. Everything uses variables.
4.2 Mixins
Create: src/app/styles/_mixins.scss
•	@mixin card() (padding + radius + shadow)
•	@mixin focus-ring() (consistent focus style)
•	@mixin responsive($breakpoint) helpers
•	@mixin page-container() (max-width + padding)
4.3 Global style entry
Create: src/app/styles/index.scss that @uses variables/mixins/typography.
Import this once in src/styles.scss (global), not per component.
Acceptance: change $color-primary and your whole app changes consistently.
________________________________________
5) Reusable UI components (mandatory)
Build these in src/app/shared/ui/ and reuse everywhere:
1.	sf-button
•	inputs: variant, size, loading, disabled
•	variants: primary/secondary/outline/danger
•	uses SCSS variables, not repeated styles
2.	sf-card
•	consistent card container
3.	sf-table
•	takes:
o	columns config
o	data
o	loading
o	paging info (page, pageSize, totalCount)
o	sort state
o	row actions (edit/delete/details)
•	emits:
o	pageChange
o	sortChange
o	action
4.	sf-form-field
•	consistent label, hint, error rendering
5.	sf-page-header
•	title + subtitle + actions slot (Create button)
6.	sf-dialog + confirm.service
•	one confirm dialog used everywhere
7.	toast.service + toast component
•	show success/error/info centrally from interceptors and facades
8.	has-permission.directive
•	*appHasPermission="'houses.manage'"
Acceptance: Feature pages should be mostly composition of shared UI.
________________________________________
6) Authentication and authorization (Admin login included)
6.1 Admin/SuperUser login flow
•	Login page for Admin/SuperUser uses backend:
o	POST /api/auth/login
o	stores accessToken + refreshToken
•	After login:
o	decode JWT
o	extract:
	roles
	permission claims from claim type perm
•	Redirect:
o	/admin dashboard shell
•	Logout:
o	call backend logout endpoint
o	clear tokens
o	navigate to /login
6.2 Guards
•	AuthGuard: must be logged in
•	RoleGuard: must be Admin or SuperUser
•	PermissionGuard: must have required permission OR be SuperUser
6.3 Menu configuration (single source)
Create one NAV_ITEMS list (in layout/sidebar) with:
•	label
•	route
•	requiredPermission (optional)
•	superUserOnly (optional)
Sidebar renders items only if allowed.
________________________________________
7) Media staged upload UX (admin forms)
Houses and Tours photo management must follow backend workflow:
•	Stage upload endpoint → returns stagedUploadId
•	In form, show a list of staged images:
o	preview thumbnail
o	Label input
o	SortOrder input/drag ordering
•	On Save (Create/Update):
o	send CommitPhotoItem[] (stagedUploadId, label, sortOrder) in request
•	If Save fails:
o	keep staged items in UI (don’t lose user work)
•	On success:
o	clear staged list
________________________________________
8) VERY DETAILED TODO LIST (Copilot executes in order)
Phase A — Create Angular app + Material
1.	Create Angular project with SCSS.
2.	Enable standalone components (default in recent Angular).
3.	Add Angular Material and select a clean theme (will be overridden by your variables).
4.	Add Angular animations.
Acceptance: app runs, Material components render.
________________________________________
Phase B — Global SCSS system (no repeated colors)
5.	Create src/app/styles/_variables.scss with all colors + spacing + radius.
6.	Create _mixins.scss and _typography.scss.
7.	Create _material-theme.scss (optional):
o	map Material palette to $color-primary, etc.
8.	Create src/app/styles/index.scss that imports all of the above.
9.	Import styles/index.scss once in src/styles.scss.
Acceptance: No feature component defines custom hex colors.
________________________________________
Phase C — Core config + API base url
10.	Create core/config/app-config.ts and API_BASE_URL injection token.
11.	Add environment config (dev/prod) for API base URL.
12.	Create core/core.providers.ts and register global providers there.
Acceptance: API base url is centralized and injectable.
________________________________________
Phase D — Auth foundation (Admin login included)
13.	Create core/auth/jwt.util.ts:
•	decode JWT
•	extract roles
•	extract permissions from perm claim type
14.	Create core/auth/token.store.ts:
•	store accessToken + refreshToken (choose localStorage initially for simplicity)
•	methods: get/set/clear
15.	Create core/auth/auth.service.ts:
•	login(email,password)
•	refresh(refreshToken)
•	logout(refreshToken) and logoutAll
•	returns typed responses
16.	Create core/auth/auth.facade.ts using signals:
•	user(), roles(), permissions(), isAuthenticated(), isSuperUser()
•	login(), logout(), refreshIfNeeded()
Acceptance: you can login and the facade knows roles/permissions.
________________________________________
Phase E — HTTP interceptors (avoid repeated code)
17.	Create core/http/auth.interceptor.ts:
•	attach access token to every API request
18.	Create core/http/correlation-id.interceptor.ts:
•	add X-Correlation-ID header (new UUID per request or per session)
19.	Create core/http/error.interceptor.ts:
•	normalize errors into one model
•	call toast service
20.	Create core/http/refresh.interceptor.ts:
•	on 401 once:
o	call refresh
o	retry original request
•	prevent refresh storms (single refresh at a time)
Acceptance: features never handle 401 manually.
________________________________________
Phase F — Guards + permission directive
21.	AuthGuard: redirects to /login if not authenticated.
22.	RoleGuard: allow only Admin or SuperUser.
23.	PermissionGuard: allow if permission exists OR SuperUser.
24.	Create shared/directives/has-permission.directive.ts:
•	hides elements if user lacks permission
Acceptance: routes and buttons are protected consistently.
________________________________________
Phase G — Shared UI library (no repeated UI)
25.	Create sf-button (wrap MatButton or custom).
26.	Create sf-card.
27.	Create sf-page-header.
28.	Create sf-empty-state.
29.	Create toast service + toast component.
30.	Create confirm dialog + confirm service.
31.	Create sf-table:
•	configurable columns
•	loading/empty states
•	pagination + sorting hooks
•	actions column with buttons (edit/delete/details)
Acceptance: Houses list can be built with sf-page-header + sf-table.
________________________________________
Phase H — Layout shell (professional dashboard)
32.	Create layout/admin-shell using Material:
•	<mat-sidenav-container>
•	left sidebar with nav
•	topbar toolbar with user + logout
•	router-outlet
33.	Create layout/sidebar:
•	nav items from a single config file
•	filter based on permissions/role
34.	Create layout/topbar:
•	display current user email
•	logout button
Acceptance: /admin shows the dashboard shell.
________________________________________
Phase I — Routing
35.	Create features/auth/auth.routes.ts:
•	/login
36.	Create layout/layout.routes.ts:
•	/admin guarded by AuthGuard + RoleGuard
•	child routes lazy-loaded:
o	houses
o	tours
o	users
o	permissions
37.	Create app.routes.ts:
•	redirects / → /admin if logged in, else /login
Acceptance: navigation works and guards block access.
________________________________________
Phase J — Login page (Admin/SuperUser)
38.	Implement features/auth/pages/login:
•	form: email + password
•	uses shared components (sf-button, sf-form-field)
•	calls auth.facade.login()
•	on success navigates to /admin
39.	Implement logout in topbar:
•	calls auth.facade.logout()
•	navigates to /login
Acceptance: Admin and SuperUser can login and logout.
________________________________________
Phase K — Houses feature (CRUD + staged photos)
40.	Create features/houses/houses.routes.ts
•	list page
•	new/edit page
41.	Create features/houses/services/houses.facade.ts with signals:
•	filters + paging + sort state
•	load list
•	load detail
•	create/update/delete
42.	House list page:
•	uses sf-table
•	filter form at top or side
•	actions: edit/delete
•	permission required: houses.manage
43.	House edit page:
•	uses house-form component
•	contains house-photos component:
o	stage upload
o	label + sort order
o	pass CommitPhotoItem[] on save
Acceptance: Admin can manage houses and photos.
________________________________________
Phase L — Tours feature (CRUD + schedules + staged photos)
44.	Create tours routes + tours facade with signals.
45.	Tour list page uses sf-table, permission tours.manage.
46.	Tour edit page:
•	tour-form
•	tour-schedules component (add/remove schedule rows)
•	tour-photos component (same staged upload pattern)
Acceptance: Admin can manage tours, schedules, photos.
________________________________________
Phase M — Users feature (SuperUser creates Admin)
47.	Users list page (permission users.manage or SuperUser-only depending on your backend rules).
48.	Create-admin page:
•	SuperUserOnly
•	calls backend create-admin endpoint
49.	Promote/remove admin actions (SuperUserOnly)
Acceptance: only SuperUser can create/promote admins.
________________________________________
Phase N — Permissions feature (SuperUser)
50.	PermissionDefinitions list:
•	create/enable/disable permissions
51.	Assign permissions to roles/users page
52.	Update sidebar visibility to reflect permission claims
Acceptance: permission catalog management works.
________________________________________
Phase O — Final consistency checks
53.	Ensure every feature page uses shared components (no duplicated UI).
54.	Ensure all colors come from _variables.scss.
55.	Ensure interceptors handle errors and show toast.
56.	Ensure guards + directive enforce permissions consistently.
57.	Add loading states (table skeleton, form busy states).
Acceptance: clean architecture + reusable UI + scalable codebase.



Don’t use *ngIf and *ngFor use always @if and@for
